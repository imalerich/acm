import java.util.ArrayList;
import java.util.Scanner;

public class Compress {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		for (int n=1; proc(s, n); n++) { }
		s.close();
	}
	
	public static boolean proc(Scanner s, int n) {
		int W = s.nextInt();
		if (W == 0) { return false; }
		double T = s.nextInt() / 100.0;
		
		// Create the initial image as a grid, this will be converted to a tree for compression
		// then converted back into a grid to be printed out.
		Grid g = new Grid(s, W);
		Node r = g.toTree();
		r.compress(T);
		
		System.out.println("Image " + n + ":");
		System.out.println(r.toGrid(g.width));
		return true;
	}
}

class Grid {
	int width;
	ArrayList<Integer> elems;
	
	Grid(int W) {
		width = W;
		elems = new ArrayList<Integer>();

		// Initialize to 0.
		for (int x=0; x<width; x++) {
			for (int y=0; y<width; y++) {
				elems.add(0);
			}
		}
	}
	
	Grid(int W, int SET) {
		width = W;
		elems = new ArrayList<Integer>();

		// Initialize to 0.
		for (int x=0; x<width; x++) {
			for (int y=0; y<width; y++) {
				elems.add(SET);
			}
		}
	}
	
	Grid(Scanner s, int W) {
		width = W;
		elems = new ArrayList<Integer>();

		// Read the list of elements from the standard input.
		for (int y=0; y<width; y++) {
			for (int x=0; x<width; x++) {
				elems.add(s.nextInt());
			}
		}
	}
	
	public void setStartingAt(Grid G, int X, int Y) {
		for (int y=0; y<G.width; y++) {
			for (int x=0; x<G.width; x++) {
				int idx = (y+Y) * width + (x+X);
				int val = G.elems.get(y * G.width + x);
				elems.set(idx, val);
			}
		}
	}
	
	public Node toTree() {
		if (width == 1) {
			Node root = new Node();
			root.perc_black = elems.get(0);
			return root;
		} else {
			Grid g0 = quadrent(0);
			Grid g1 = quadrent(1);
			Grid g2 = quadrent(2);
			Grid g3 = quadrent(3);
			
			Node n0 = g0.toTree();
			Node n1 = g1.toTree();
			Node n2 = g2.toTree();
			Node n3 = g3.toTree();
			
			Node root = new Node();
			root.c0 = n0;
			root.c1 = n1;
			root.c2 = n2;
			root.c3 = n3;
			return root;
		}
	}
	
	public Grid quadrent(int Q) {
		Grid g = new Grid(width/2);
		int startx = 0;
		int starty = 0;
		if (Q == 1) {
			startx = width/2;
		} else if (Q == 2) {
			starty = width/2;
		} else {
			startx = width/2;
			starty = width/2;
		}

		for (int y=0; y<width/2; y++) {
			for (int x=0; x<width/2; x++) {
				g.elems.add( elems.get((y+starty) * width + (x+startx)) );
			}
		}

		return g;
	}
	
	@Override
	public String toString() {
		String out = "";
		for (int i=0; i<elems.size(); i++) {
			out += elems.get(i);
			out += (i+1) % width == 0 ? "\n" : " ";
		}

		// Exclude the extra added space.
		return out.substring(0, out.length()-1);
	}
}

class Node {
	Node parent;
	Node c0;
	Node c1;
	Node c2;
	Node c3;
	
	public double perc_black;
	
	Node() {
		parent = null;
		c0 = null;
		c1 = null;
		c2 = null;
		c3 = null;
		perc_black = 0.0;
	}
	
	Node(Node P) {
		parent = P;
		c0 = null;
		c1 = null;
		c2 = null;
		c3 = null;
		perc_black = 0.0;
	}
	
	public Grid toGrid(int width) {
		if (hasChildren()) {
			Grid g0 = c0.toGrid(width/2);
			Grid g1 = c1.toGrid(width/2);
			Grid g2 = c2.toGrid(width/2);
			Grid g3 = c3.toGrid(width/2);
			
			Grid g = new Grid(width);
			g.setStartingAt(g0, 0, 0);
			g.setStartingAt(g1, width/2, 0);
			g.setStartingAt(g2, 0, width/2);
			g.setStartingAt(g3, width/2, width/2);
			return g;
		} else {
			Grid g = new Grid(width, (perc_black > 0) ? 0 : 1);
			return g;
		}
	}
	
	void compress(double threshold) {
		if (!hasChildren()) {
			return;
		} else {
			// First compress ourself.
			if (percentageBlack() > threshold) {
				killallChildren();
				perc_black = 1.0;
			} else if (1 - percentageBlack() > threshold) {
				killallChildren();
				perc_black = 0.0;
			} else {
				 // No compression on self, compress children instead.
				c0.compress(threshold);
				c1.compress(threshold);
				c2.compress(threshold);
				c3.compress(threshold);
			}
		}
	}
	
	int depth() {
		if (!hasChildren()) {
			return 1;
		} else {
			int d0 = c0.depth();
			int d1 = c1.depth();
			int d2 = c2.depth();
			int d3 = c3.depth();
			return Math.max(Math.max(d0, d1), Math.max(d2, d3));
		}
	}
	
	void addallChildren() {
		c0 = new Node(this);
		c1 = new Node(this);
		c2 = new Node(this);
		c3 = new Node(this);
	}
	
	Pair quad() {
		if (parent == null) {
			return new Pair();
		} else if (parent.c0 == this) {
			return new Pair(0, 0);
		} else if (parent.c1 == this) {
			return new Pair(1, 0);
		} else if (parent.c2 == this) {
			return new Pair(0, 1);
		} else {
			return new Pair(1, 1);
		}
	}
	
	void killallChildren() {
		c0 = null;
		c1 = null;
		c2 = null;
		c3 = null;
	}
	
	double percentageBlack() {
		if (!hasChildren()) {
			return perc_black;
		} else {
			return ( c0.percentageBlack() + 
					 c1.percentageBlack() +
					 c2.percentageBlack() +
					 c3.percentageBlack() ) / 4.0;
		}
	}
	
	boolean hasChildren() {
		return c0 != null;
	}
}

class Pair {
	int x;
	int y;
	
	Pair() {
		x = 0;
		y = 0;
	}
	
	Pair(int X, int Y) {
		x = X;
		y = Y;
	}
	
	Pair(String line) {
		Scanner s = new Scanner(line);
		x = s.hasNextInt() ? s.nextInt() : 0;
		y = s.hasNextInt() ? s.nextInt() : 0;
		s.close();
	}
	
	double dist(Pair other) {
		return Math.sqrt(Math.pow(other.x - x, 2) + Math.pow(other.y - y, 2));
	}
	
	@Override
	public String toString() {
		return "(" + x + ", " + y + ")";
	}
}